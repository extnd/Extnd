<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-nd-UIDocument-method-constructor'><span id='Ext-nd-UIDocument-cfg-defaultFieldWidth'><span id='Ext-nd-UIDocument-cfg-applyDominoKeywordRefresh'><span id='Ext-nd-UIDocument-cfg-convertFields'><span id='Ext-nd-UIDocument-cfg-createActionsFrom'><span id='Ext-nd-UIDocument-cfg-showActionbar'><span id='Ext-nd-UIDocument'>/**
</span></span></span></span></span></span></span> * @class Ext.nd.UIDocument Converts fields and actionbars of a Domino form/page into
 *        Ext equivalents Simple example:
 * &lt;pre&gt;&lt;code&gt;
  var uidoc = new Ext.nd.UIDocument();
  uidoc.render('myDiv'); // to render to a specified location
  -- or --
  uidoc.render(); // to render to an Ext.Viewport
 &lt;/code&gt;&lt;/pre&gt; 
 * More complex example:&lt;pre&gt;&lt;code&gt;
  var uidoc = new Ext.nd.UIDocument({
    showActionbar : false,
    convertFields : false
  });
  new Ext.Viewport({
    layout: 'fit',
    items: uidoc
  });
 &lt;/code&gt;&lt;/pre&gt;
 * @cfg {Boolean} showActionbar Whether or not to read in the form/page DXL
 *      behind the scences and build an Ext.Toolbar from domino actions
 *      (Defaults to true)
 * @cfg {String} createActionsFrom Set to 'document' if you want to create the actionbar
 * from the actions domino sends after it evaluates hide-when formulas.  Set to 'dxl' if
 * you want to create the actionbar from what is defined in Designer.  
 * @cfg {Boolean} convertFields Determines whether to convert form fields to Ext
 *      fields. (Defaults to true)
 * @cfg {Boolean} applyDominoKeywordRefresh Determines whether to apply the
 *      postback onchange event that Domino sends for Keyword fields set to
 *      &quot;Refresh fields on keyword change&quot;. Defaults to true.
 * @cfg {Number} defaultFieldWidth
 * @constructor Creates a new Form component
 * @param {Object}
 *            config Configuration options
 */
Ext.nd.UIDocument = function(config){
    
    config = config || {};
   
    var me = this,
    	sess = Ext.nd.Session,
    	db = sess.currentDatabase,
    	//TODO: this needs to go away soon (the use of Ext.nd.currentUIDocument.*)
    	currentUIDocument = Ext.nd.currentUIDocument || {};
    
    // now just apply currentUIDocument to 'this' so we get what the agent says
    // about this uidocument (such as UNID, form name, etc.)
    Ext.apply(me, currentUIDocument);
	me.document = me.document || {};
	
    // for backwards compat (not sure if any devs are using this)
    me.uidoc = currentUIDocument; 

    // defaults
    me.dbPath = db.webFilePath;
    me.showActionbar = true;
    me.createActionsFrom = 'dxl';
    me.convertFields = true;
    me.applyDominoKeywordRefresh = true;
    me.defaultFieldWidth = 120;
    me.documentLoadingWindowTitle = &quot;Opening&quot;;
    me.documentUntitledWindowTitle = &quot;Untitled&quot;;
    me.useDocumentWindowTitle = true;
    me.documentWindowTitleMaxLength = 16;
    me.refreshMessage = 'Refreshing document...';
    
    // developer can specify where the toolbar should appear
    me.toolbarRenderTo; 
    me.dateTimeFormats = Ext.nd.dateTimeFormats;
    
    // for a page we need this hack to get the page name (that we store in the formName variable)
    // we do this since the UIDocument.js agent couldn't get this info and
    // domino does not send the page name in the form tag like it does for forms
    // ALSO - for special forms like $$ViewTemplate or $$SearchTemplae, '_DominoForm' is sent as the form name
    
    if (typeof me.formName == 'undefined') {
    	var frms = document.forms,
    		href, search, start, end;
    		
        if (frms.length == 0 || frms[0].name.substring(1) == '' || frms[0].name.substring(1) == 'DominoForm') {
            
            href = location.href.toLowerCase();
           	search = location.search.toLowerCase();
           	start = href.indexOf(me.dbPath.toLowerCase()) + me.dbPath.length;
           	end = (search != &quot;&quot;) ? href.indexOf(search) : href.length;
            	
            me.formName = location.href.substring(start, end);
            
        } else {
            me.formName = document.forms[0].name.substring(1);
        }
    }

    // since we use Ext.form.BasicForm we need to make sure initialConfig is set now
    if (!me.initialConfig) {
        me.initialConfig = {};    
    }
    // now apply anything passed in
    Ext.apply(me.initialConfig, config);  
    // and now set any config params passed in to override defaults
    Ext.apply(me, config);
    
    // formUrl is either passed in or built from dbPath and formName
    me.formUrl = (me.formUrl) ? me.formUrl : me.dbPath + me.formName;
    
    // call parent's constructor
    Ext.nd.UIDocument.superclass.constructor.apply(me, arguments);
};

Ext.extend(Ext.nd.UIDocument, Ext.form.FormPanel, {
   
    initComponent : function(){
    	
    	var me = this;
    	
        me.setupToolbars();
        
        me.addEvents(        
<span id='Ext-nd-UIDocument-event-beforeclose'>                /**
</span>                 * @event beforeclose Fires just before the current document is closed (equivalent to the NotesUIDocument QueryClose event).
                 * @param {Ext.nd.UIDocument} this
                 */
                'beforeclose',        
<span id='Ext-nd-UIDocument-event-beforemodechange'>                /**
</span>                 * @event beforemodechange Fires just before the current document changes modes (from Read to Edit mode, or from Edit to Read mode) (equivalent to the NotesUIDocument QueryModeChange event).
                 * @param {Ext.nd.UIDocument} this
                 */
                'beforemodechange',        
<span id='Ext-nd-UIDocument-event-beforeopen'>                /**
</span>                 * @event beforeopen (TODO: Not yet implemented) Fires just before the current document is opened (equivalent to the NotesUIDocument QueryOpen event).
                 * @param {Ext.nd.UIDocument} this
                 */
                'beforeopen',        
<span id='Ext-nd-UIDocument-event-beforesave'>                /**
</span>                 * @event beforesave Fires just before the current document is saved (equivalent to NotesUIDocument QuerySave)
                 * @param {Ext.nd.UIDocument} this
                 */
                'beforesave',        
<span id='Ext-nd-UIDocument-event-open'>                /**
</span>                 * @event open Fires just after the current document is opened (equivalent to NotesUIDocument PostOpen and OnLoad events.)
                 * @param {Ext.nd.UIDocument} this
                 */
                'open');
             
        // now call parent initComponent
        Ext.nd.UIDocument.superclass.initComponent.call(me);   

		// parent's initComponet create the form so let's now make sure the url is set
		me.setPostUrl();
		
        // take over Domino's generated _doClick function
        if (Ext.isFunction(_doClick)){
        	_doClick = me._doClick.createDelegate(me);
        }
    },
    
    // private
  	// change the hash reference by prepending xnd-goto
 	// will fix an IE issue with the layout not positioning correctly
    // when the page loads and 'jumps' to the &lt;a href&gt; reference in the hash
    // TODO: need to add code to instead &quot;scroll&quot; to the hash reference
    _doClick : function(v, o, t, h) {
		var form = this.getForm();
	  	if (form.onsubmit) {
		     var retVal = form.onsubmit();
		     if (typeof retVal == &quot;boolean&quot; &amp;&amp; retVal == false)
		       return false;
		}
		var target = document._domino_target;
		if (o.href != null) {
		  if (o.target != null)
		     target = o.target;
		} else {
		  if (t != null)
		    target = t;
		}
		form.el.dom.target = target;
		form.findField(&quot;__Click&quot;).setValue(v);
		
		// modify hash to prepend 'xnd-goto'
		if (h != null) {
		  form.el.dom.action += h.replace('#','#xnd-goto');
		}
		
		// call submit from the dom and not the Ext form since it will do an Ajax submit
		// but the dom submit will do a standard submit which is what domino is needing to do
		// if calling _doClick (usually a refresh fields on keyword change type of submit)
		form.el.dom.submit({standardSubmit : true});
		return false;
	},
	
    // private
    // overriding the FormPanels createForm method with our own 
    // so we can reuse the domino generated form
    createForm : function(){
        delete this.initialConfig.listeners;
        if (!this.items) {
            // this is just something to make FormPanel happy
            this.items = {xtype: 'label', hidden: true};
        }
        /* TODO: for now we use document.forms[0] since we 
         * currently only support loading forms/documents 
         * by themselves or in an iframe.  Eventually we want
         * to provide support to open forms/documents without 
         * the need to be in an iframe
         */
        return new Ext.form.BasicForm(document.forms[0], this.initialConfig);
    },
    
    /* to support users coming from older versions of Ext.nd where you did
     * not have to specify 'where' to render to so we will render to
     * an Ext.Viewport like previous versions did when the render method
     * is called without any arguments
     */
    render : function(){
        if (arguments.length == 0) {
          //this.render(document.body);
          new Ext.Viewport({
             layout: 'fit',
             items: this
          });
        } else {
            Ext.nd.UIDocument.superclass.render.apply(this, arguments);    
        }
        
    },
    
   onRender : function(ct, position){
        
        /* make sure that body is already set to our domino 
         * form's Element (this.form.el) we do this so that 
         * superclass.onRender call will not create a 
         * new body (which is a form element) but instead, 
         * use the form element (our domino one) instead
         */        
        this.body = this.form.el;
            
        Ext.nd.UIDocument.superclass.onRender.call(this, ct, position);
        
        /* apply any custom styles from the bodyStyle config
         * the .supercalls.onRender normally does this but since
         * we forced this.body = this.form.el we need to now
         * apply the bodyStyle config ourselves
         */
        if(this.bodyStyle){
            this.body.applyStyles(this.bodyStyle);
        }
        
        /* make sure any buttons know about uiView and uiDocument
         * we do this after the superclass.onRender since that
         * is where fbar for the buttons gets setup
         */
        this.setupButtons();
    },
    
    afterRender : function(){
    
    
        /* make an Ajax call to our DXLExport agent 
         * to get field info however, 
         * only need to do this if convertFields is true, 
         * otherwise, there is no need
         */
        if (this.convertFields) {
            
            Ext.Ajax.request({
                method: 'GET',
                disableCaching: true,
                success : this.doConvertFieldsCB, 
                failure : this.doConvertFieldsCB,
                arguments : arguments,
                scope: this,
                url: Ext.nd.extndUrl + 'DXLExporter?OpenAgent&amp;db=' + this.dbPath + '&amp;type=form&amp;name=' + this.formName
            });

            // need to go ahead and make sure we set the layout 
			// since we are making the above Ajax call
			if (Ext.isString(this.layout)) {
				this.layout = new Ext.Container.LAYOUTS[this.layout.toLowerCase()](this.layoutConfig);
			}
			this.setLayout(this.layout);
			Ext.nd.UIDocument.superclass.afterRender.apply(this, arguments);
			
        } else {

            Ext.nd.UIDocument.superclass.afterRender.apply(this, arguments);
            
            // seen some issues where this.layout is a string (this.layout = 'fit') and thus
            // does not have a layout() method which doLayout() calls
            if (typeof this.layout == 'object') {
                this.doLayout();
            } 
            
            this.fireEvent('open', this);

        }

    },

    edit : function(config) {
    	var me = this;
        if (me.fireEvent(&quot;beforemodechange&quot;, me) !== false) {
            me.onEdit(config);
        }
    },

    onEdit : function(config){
        var me = this,
        	uiView = me.getUIView(),
        	uiViewName = (uiView) ? uiView.viewName : '0',
        	unid = me.document.universalID;
        
        location.href = me.dbPath + uiViewName + '/' + unid + '?EditDocument'
    },
    
    save : function(config) {
    	var me = this;
    	if (me.fireEvent(&quot;beforesave&quot;, me) !== false) {
            me.onSave(config);
        }
    },
    
    onSave : function(config) {
        
        var frm = this.getForm(),
        	fieldModDate;
        
        // TODO: need to add documentation code for the fact that config could be an object or a boolean
        config = (typeof config == 'undefined') ? {closeOnSave : false} : (typeof config == 'boolean') ? {closeOnSave : config} : config;
    	
    	// disable the %%ModDate field that domino adds since having it there could cause rep/save conflicts
    	fieldModDate = frm.findField('%%ModDate');
    	if (fieldModDate) {
    		fieldModDate.disable();
    	}
    	
    	var cb = {};
    	if (config.success) {
    		cb.success = config.success;
    		delete config.success;
    	}
    	if (config.failure) {
    		cb.failure = config.failure;
    		delete config.failure;
    	}
    	if (config.scope) {
    		cb.scope = config.scope;
    		delete config.scope;
    	}
    	
        frm.submit(Ext.apply({
          	method: 'POST',
          	//success: (config.closeOnSave) ? this.close : Ext.emptyFn,
          	success: this.onSaveCallback,
          	failure: this.onSaveCallback,
          	cb : cb,
          	scope: this            
        },config));
    },
       
    onSaveCallback : function(form, action){
    	var me = this,
    		options = action.options,
    		cb = options.cb,
    		result = action.result,
    		msg = result.msg,
    		unid = result.unid || result.universalID;
    		
    	if (unid) {
    		me.setUniversalID(unid);
    	}
    	
    	if (result.success) {
    		if (cb.success) {
    			cb.success.apply(cb.scope || me, arguments);
    		}
    	} else {
    		if (cb.failure) {
    			cb.failure.apply(cb.scope || me, arguments);
    		}
    	}
    	
    },
    
    close : function(unid){
        if (this.fireEvent(&quot;beforeclose&quot;, this) !== false) {
            this.onClose(unid);
        }
    },
    
    onClose : function(unid) {
        /*
         * return true means that we were able to call the component's remove/hide/close action
         * return false means that we couldn't find a component and thus couldn't do anything
         * 
         */
        
        var returnValue = false;
        var target = this.getTarget();
        
        if (target) {
            
            switch (target.getXType()) {
                case 'window':
                    if (target.closeAction == 'close') {
                        target.close();
                        returnValue = true;  
                    } else {
                        target.hide();
                        returnValue = true;
                    }
                    break;
                case 'tabpanel':
                    target.remove(target.getActiveTab());
                    returnValue = true;
                    break;
                default:
                    if (target.remove) {
                        var iframeOwnerCt = this.getIframeOwnerCt();
                        if (iframeOwnerCt) {
                            target.remove(this.iframeOwnerCt);
                            returnValue = true;
                        } else {
                            returnValue = false;
                        }
                    } else {
                        returnValue = false;
                    }
                    break;
            } // eo switch
        } else {
            if (this.editMode) {
                // open in read mode if already in edit mode and no target
                var uiView = this.getUIView();
                var uiViewName = (uiView) ? uiView.viewName : '0';
                var unid = (unid) ? unid : this.document.universalID;
                if (unid) {
                	location.href = this.dbPath + uiViewName + '/' + unid + '?OpenDocument'
                } else {
                	location.href = this.dbPath;
                }
            } else {
                returnValue = false;
            }
        }   
        
        return returnValue;
    },
    
    
    // private 
    setPostUrl : function() {
    	
    	// make sure we have a url to post to
        // it can be blank when the developer is opening a doc in read mode but still
        // wants to call the uidoc's save method.  since domino sets the action attribute to blank
        // when in read mode, we have to create it ourselves
    	
    	var me = this,
    		frm = me.getForm(),
    		action, uiView, uiViewName, unid;
    	
    	if (!frm.url) {
    		action = me.getForm().el.dom.action;
			if (action == &quot;&quot;) {
				uiView = me.getUIView();
				uiViewName = (uiView) ? uiView.viewName : '0';
				unid = me.document.universalID;
				frm.url = me.dbPath + uiViewName + '/' + unid + '?SaveDocument';
			} else {
				frm.url = action;
			}
    	}
    },
    
    // private 
    setUniversalID : function(unid) {
    	
    	var me = this,
    		frm = me.getForm(),
    		uiView = me.getUIView(),
			uiViewName = (uiView) ? uiView.viewName : '0',
			unid = unid || me.document.universalID;
			
		frm.url = me.dbPath + uiViewName + '/' + unid + '?SaveDocument';
		me.document.universalID = unid;
		me.isNewDoc = false;
    },
    
    // private
    setupToolbars : function() {
       
        var tbId;
        
        if (this.tbar) {
        
            tbId = 'xnd-doc-tbar-' + Ext.id();
           
            if (Ext.isArray(this.tbar)) {
                // add the tbar|bbar|buttons array to our on Actionbar items config
                this.tbar = new Ext.nd.Actionbar({
                    id: tbId,
                    noteName: (this.showActionbar) ? this.formName : '',
                    uiView: this.getUIView(),
                    uiDocument : this.getUIDocument(),
                    target: this.getTarget() || null,
                    createActionsFrom: this.createActionsFrom,
                    items: this.tbar
                });
            }
            else {
                // tbar isn't an array but probably an instance of Ext.Toolbar
                // we still need to add the uiDocument and uiView references
                this.tbar.id = tbId;
                this.tbar.target = this.getTarget() || null;
                this.tbar.uiDocument = this.getUIDocument();
                this.tbar.uiView = this.getUIView();
            }
            // a tbar config will override the domino actionbar 
            // so be sure to remove the domino generated actionbar
            this.dominoActionbar = new Ext.nd.util.DominoActionbar();
            this.dominoActionbar.hide();

        } else {

            if (this.showActionbar) {
                this.tbar = new Ext.nd.Actionbar({
                    id : tbId,
                    noteType: 'form',
                    noteName: this.formName,
                    uiView: this.getUIView(),
                    uiDocument: this.getUIDocument(),
                    target: this.getTarget() || null,
                    createActionsFrom: this.createActionsFrom,
                    renderTo : (this.toolbarRenderTo) ? this.toolbarRenderTo : null
                });
            }
            
        } // eo if (this.tbar)
        
    },
    
    setupButtons : function() {
        
        // handle special case of 'buttons' and 'fbar'
        if (this.buttons) { 
            // you can only have one and if buttons exist they will
            // supersede fbar.  however, keep in mind that the code
            // in Ext.Panel simply creates a fbar and sets the
            // items array to buttons.  So we only need to
            // add uiDocument and uiView to fbar
            
            // make sure it exists (it should but just in case
            if (this.fbar) {
                this.fbar.target = this.getTarget() || null;
                this.fbar.uiDocument = this.getUIDocument();
                this.fbar.uiView = this.getUIView();            
            }
        }
    },
    
    /* called only when convertFields is set to true
     * and processes the response from the dxl export 
     * of field info
     */
    // private
    doConvertFieldsCB : function(response, options) {

        // load in our field defintions
        this.fieldDefinitions = new Ext.util.MixedCollection(false,this.getFieldDefinitionKey);
        this.fieldDefinitions.addAll(Ext.DomQuery.select('field', response.responseXML));
        var noteinfo = Ext.DomQuery.select('noteinfo', response.responseXML);
      	this.noteinfo = {
      		unid : Ext.DomQuery.selectValue('@unid', noteinfo),
      		noteid : Ext.DomQuery.selectValue('@noteid', noteinfo),
      		sequence : Ext.DomQuery.selectValue('@sequence', noteinfo)
      	};
  
        // convert the fields
        this.doConvertFields();

        /* this is called in the form panel's onRender method but we 
         * need to call it again here since the domino fields didn't exist
         * in the items array until now
         */ 
        this.initFields();
        
        /* need to call parent afterRender since this callback function
         * was called from this classes afterRender method
         * Ext.nd.UIDocument.superclass.afterRender.call(this);
         */  
        Ext.nd.UIDocument.superclass.afterRender.apply(this, options.arguments)
        
        // since we have dynamically added Ext form fields we need
        // to call doLayout
        this.doLayout();	   
		this.fireEvent('open', this);
		
    },

    doConvertFields : function(){
    
        var elem, key;
        
        // 1st, convert all elements that do not use an 'xnd-*' class
        var elements = this.form.el.dom.elements;
        var allElements = new Ext.util.MixedCollection();

        for (var i=0, len = elements.length; i &lt; len; i++) {
            key = elements[i].id ? elements[i].id : Ext.id();
            allElements.add(key, elements[i]);
        }
        Ext.each(allElements.items, function(item, index, allItems){
            if (!this.convertFromClassName(item, false)) {
                this.convertFromTagName(item);
            }
        },this);
                
        /* now handle the elements with 'xnd-' classNames
         * we do this second/last so that any new elements introduced 
         * by Ext are not processed again
         */
        var xndElements = Ext.DomQuery.select('*[class*=xnd-]');
        Ext.each(xndElements, function(elem, index, allItems){
            this.convertFromClassName(elem, true);
        }, this);
        
        
    }, // end function doConvertFields()
    
    getFieldDefinition : function(el) {
        if (el.name) {
            return this.fieldDefinitions ? this.fieldDefinitions.get(el.name) : null;    
        } else {
            return null;
        }
    },
    
    // private
    convertFromTagName : function(el) {
        
        switch (el.tagName) {
            case 'BUTTON':
                // do nothing for now on buttons
                break;
                
            case 'SELECT':
                /* for a dialoglist set to use a view for choices, 
                 * domino causes problems in that it will send 
                 * a select tag down without any options!
                 * so therefore, we have to check for that
                 */
                var dfield = this.getFieldDefinition(el);
                if (dfield){
                    var allowMultiValues = (Ext.DomQuery.selectValue('@allowmultivalues',dfield) == 'true') ? true : false;
                    var allowNew = (Ext.DomQuery.selectValue('keywords/@allownew',dfield) == 'true') ? true : false;
                    var choicesdialog = Ext.DomQuery.selectValue('@choicesdialog',dfield);
                    if (choicesdialog == 'view') {
                        this.convertToPickList(el, {
                            type : 'custom',
                            viewName : Ext.DomQuery.selectValue('@view', dfield),
                            column : Ext.DomQuery.selectNumber('@viewcolumn', dfield),
                            multipleSelection : allowMultiValues,
                            allowNew : allowNew
                        });
                    } else {
                        this.convertSelectToComboBox(el, true);
                    }
                } else {
                    this.convertSelectToComboBox(el, true);
                }
                break;
                
            case 'TEXTAREA':
                this.convertToTextAreaField(el);
                break;

            case 'FIELDSET':
                this.convertToFieldSet(el);
                break;
                
            case 'INPUT':
                var type = el.getAttribute('type');
                switch (type) {
                    case 'hidden':
                        this.convertToHiddenField(el);
                        break;
                    case 'checkbox':
                        this.convertToCheckbox(el);
                        break;
                    case 'radio':
                        this.convertToRadio(el);
                        break;
                    case 'file':
                    	this.convertToFileUpload(el);
                    	break;
                    default:
                        this.convertFromDominoFieldType(el);
                        
                } // end switch(type)
                break;
                
            default:
                this.convertToTextField(el);
                break;
                
        } // end switch(el.tagName)
            
    },
    
    //private
    convertFromDominoFieldType : function(el) {
        
        var dfield = this.getFieldDefinition(el);
        if (dfield) {
            var dtype = Ext.DomQuery.selectValue('@type',dfield);
            switch (dtype) {
                case 'password':
                case 'text':
                    this.convertToTextField(el);
                    break;
                case 'datetime':
                    this.convertToDateTimeField(el);
                    break;   
                case 'number':
                    this.convertToNumberField(el);
                    break;
                case 'names':
                    this.convertNamesField(el);
                    break;                                     
                case 'keyword':
                    this.convertKeywordField(el);
                    break;
                    
            } // eo switch
        } // eo if (dfield)
        else {
            this.convertToTextField(el);
        }        
    },
    
    // private
    getFieldDefinitionKey : function(theField){
        
        return Ext.DomQuery.selectValue('@name',theField);    
    },
    
    convertFromClassName : function(el, doConvert){
    
        var arClasses = el.className.split(' ');
        var elHasXndClass = false;
        
        // check classes first
        for (var c = 0; c &lt; arClasses.length; c++) {
            var cls = arClasses[c];
            
            switch (cls) {
                case 'xnd-combobox':
                    if (doConvert) {
                        this.convertSelectToComboBox(el, true);
                    }
                    elHasXndClass = true;
                    break;
                    
                // doesn't work since domino sends a text field instead of a
                // select when the option for 'allow values not in list' is
                // selected
                case 'xnd-combobox-appendable':
                    if (doConvert) {
                        this.convertSelectToComboBox(el, false);
                    }
                    elHasXndClass = true;
                    break;
                    
                case 'xnd-date':
                    if (doConvert) {
                        this.convertToDateField(el)                        
                    }
                    elHasXndClass = true;
                    break;
                    
                case 'xnd-number':
                    if (doConvert) {
                        this.convertToNumberField(el);
                    }
                    elHasXndClass = true;
                    break;
                    
                case 'xnd-time':
                    if (doConvert) {
                        this.convertToTimeField(el);
                    }
                    elHasXndClass = true;
                    break;
    
                case 'xnd-htmleditor':
                    if (doConvert) {
                        this.convertToHtmlEditor(el);
                    }
                    elHasXndClass = true;
                    break;
                                                            
                case 'xnd-picklist-names':
                    if (doConvert) {
                        this.convertToNamePicker(el);
                    }
                    elHasXndClass = true;
                    break;
                    
                case 'xnd-ignore':
                    elHasXndClass = true;
                    break;
                    
                default:
                    break;
            } // end switch(cls)
        } // end for arClasses
        // return the value of elHasXndClass 
        // so we know if this field was or could have been converted

        return elHasXndClass;
    },
        
    // private
    convertToHiddenField : function(el){
        // not sure if we need to do anything more
        this.convertToTextField(el);
    },
    
    
    // private
    convertToTextField : function(el){
        
        // for normal input fields
        var f = new Ext.form.TextField({
            id: (el.id ? el.id : el.name),
            width : this.getFieldWidth(el)
        });
        f.applyToMarkup(el);
        // now add to items
        this.form.items.add(f);
                                        
    },

    // private
    convertToFieldSet : function(el){
        
        //var title = Ext.DomQuery.selectValue('legend',el,'');
        var fs = new Ext.form.FieldSet({
            id: (el.id ? el.id : el.name),
            //title : title,
            autoHeight: true,
            autoWidth : true
        });
        fs.applyToMarkup(el);
                                        
    },

    // private
    convertNamesField : function(el){
        
        var dfield = this.getFieldDefinition(el);
        if (dfield) {
            var allowMultiValues = (Ext.DomQuery.selectValue('@allowmultivalues',dfield) == 'true') ? true : false;
            var allowNew = (Ext.DomQuery.selectValue('keywords/@allownew',dfield) == 'true') ? true : false;
            var choicesdialog = Ext.DomQuery.selectValue('@choicesdialog',dfield, false);
            
            if (choicesdialog) {

                switch (choicesdialog) {
                    
                    case 'addressbook':
                    this.convertToNamePicker(el, {
                        multipleSelection : allowMultiValues,
                        allowNew : allowNew
                    });
                    break;
                    
                    case 'acl':
                    this.convertToACLDialog(el, {
                        multipleSelection : allowMultiValues,
                        allowNew : allowNew                
                    });
                    break;
                
                    case 'view':
                    this.convertToPickList(el, {
                        type : 'custom',
                        viewName : Ext.DomQuery.selectValue('@view', dfield),
                        column : Ext.DomQuery.selectNumber('@viewcolumn', dfield),
                        multipleSelection : allowMultiValues,
                        useCheckboxSelection : true,
                        allowNew : allowNew                    
                    });
                    break;
                } // eo switch
                
            } else {
                this.convertToTextField(el);
            }
        }
    },
        
    // private
    convertToNamePicker : function(el, config){
        
        config = config || {};
        
        var nm = new Ext.nd.form.PickListField(Ext.apply({
            type: 'names',
            id: (el.id ? el.id : el.name),
            width : this.getFieldWidth(el)
        }, config));
        nm.applyToMarkup(el);
        // now add to items
        this.form.items.add(nm);

    },
    
    // private
    convertToPickList : function(el, config){

        var pl = new Ext.nd.form.PickListField(Ext.apply({
            id: (el.id ? el.id : el.name),
            width : this.getFieldWidth(el)
        }, config));
        pl.applyToMarkup(el);
        // now add to items
        this.form.items.add(pl);
        
    },
    
    // private
    convertToTextAreaField : function(el){
        
        var ta = new Ext.form.TextArea({
            id: (el.id ? el.id : el.name),
            resizable: true
        });
        ta.applyToMarkup(el);
        // now add to items
        this.form.items.add(ta);                        

    },
    
    // private : function(el) {
    convertToFileUpload : function(el){
    	
    	/* can only convert to the nicer Ext UploadField
    	 * if the user has loaded the Ext.ux.form.FileUploadFile code
    	 * 
    	 * If you want to create file uploads on the fly
    	 * then you will need to set this notes.ini parameter
    	 * DominoDisableFileUploadChecks=1
    	 * 
    	 * That parameter will allow for you to create file inputs
    	 * but note that the name attribute needs to start as '%%File.n'
    	 * where n = a unique number/string for each file upload field
    	 */ 
    	
    	if (Ext.ux.form.FileUploadField) {
    		
    		// make sure el has an id
    		el.id = el.id || Ext.id();
    		
    		var attr = el.attributes;
	        var style = '';
	        var cls = '';
	        if (attr) {
	        	var oStyle = attr.getNamedItem('style');
	        	var oCls = attr.getNamedItem('class');
	            style = oStyle ? oStyle.value : '';
	            cls = oCls ? oCls.value : '';
	        }
	        
	        var sName = el.name;
	        var sId = el.id;
	        
	        var dh = Ext.DomHelper;
	    	
	        var parentParagraphTag = Ext.get(el).findParentNode('p', true);
	        if (parentParagraphTag) {
	        	var innerMarkup = parentParagraphTag.innerHTML;
	        	dh.insertBefore(parentParagraphTag, {
	        		tag : 'div',
	        		html : innerMarkup
	        	});
	       		Ext.removeNode(parentParagraphTag);
	       		
	       		// need a new reference to el since the original
	       		// reference just got removed
	       		el = Ext.getDom(sId);
	        }
	        	    	
	        // define a place holder for the fileuploadfield
        	var fileUploadContainer = dh.insertBefore(el, {
            	tag : 'div',
            	id : Ext.id()
        	}, true);

        	// render the new Ext fileupload field
	        var uploadField = new Ext.ux.form.FileUploadField({
	        	id : sId,
	        	name : sName,
				renderTo : fileUploadContainer.id,
				width : this.getFieldWidth(el)
			});
			
			el.name = Ext.id(); // wipe out the name in case somewhere else they have a reference
	        // now remove the domino generated fileupload field
	        Ext.removeNode(el);
	        
	        // now add to items
	        this.form.items.add(uploadField);
	        
    	} else {
    		// Ext's fileuploadfield code isn't loaded
    		// so at least conver the input area to the Ext look-n-feel
    		this.convertToTextField(el);
    	}
    	
    },
    // private
    convertToHtmlEditor : function(el){
    
        // Html Editor needs QuickTips inorder to work
        Ext.QuickTips.init();
        
        // get the tagName since the developer may add the class to a rich text
        // field (textarea) or a div
        var tag = el.tagName.toLowerCase();
        var ed;
        
        if (tag == 'div') {
            ed = new Ext.form.HtmlEditor({
                id: (el.id ? el.id : el.name),
                renderTo: el
            });
            
        } else {
                       
            // define a place holder for the HtmlEditor
            var heContainer = Ext.DomHelper.insertBefore(el, {
                tag: 'div',
                style: {
                    width: 500
                }
            }, true);
            
            /* now append (move) the textarea into the heContainer
             * this is needed since the renderTo of HtmlEditor will try and
             * render into the parentNode of the textarea and since domino
             * sometimes wraps &lt;font&gt; tags around the textarea, 
             * the renderTo code will break
             */
            
            heContainer.dom.appendChild(el);
            
            // make sure the textarea is at least 510px for the richtext toolbar
            Ext.get(el).setStyle({
                width: 510
            });
            
            // now create the HtmlEditor and apply it to the textarea field
            ed = new Ext.form.HtmlEditor();
            ed.applyToMarkup(el);
            
            
            /* strip off the passthru square brackets and div we add 
             * in order to have passthru html when in read mode
             */
            ed.on('beforepush', function(editor, html){
                var htmlBefore = &quot;[&lt;div class='xnd-htmleditor-read'&gt;&quot;;
                var htmlAfter = &quot;&lt;/div&gt;]&quot;;
                
                var start = htmlBefore.length;
                var end = html.length - htmlAfter.length;
                
                if (html.indexOf(htmlBefore) == 0) {
                    html = html.substring(start, end)
                }
                
                editor.getEditorBody().innerHTML = html;
                return false;
            });
            
            /* add back the passthru square brackets and div 
             * in order to have passthru html when in read mode
             */
            ed.on('beforesync', function(editor, html){
                editor.el.dom.value = &quot;[&lt;div class='xnd-htmleditor-read'&gt;&quot; +
                html +
                &quot;&lt;/div&gt;]&quot;;
                return false;
            });
            
        }
        
        // now add to items
        this.form.items.add(ed);
        
    },
    
    convertToNumberField : function(el){
        
        var nbr = new Ext.form.NumberField({
            width : this.getFieldWidth(el)
        });
        nbr.applyToMarkup(el);
        // now add to items
        this.form.items.add(nbr);                        

    },
    
    // private
    convertToDateTimeField : function(el) {
        var dfield = this.getFieldDefinition(el);
        if (dfield) {
            var show = Ext.DomQuery.selectValue('datetimeformat/@show',dfield);
            switch (show) {
                case &quot;date&quot;:
                    this.convertToDateField(el);
                    break;  
                case &quot;time&quot;:
                    this.convertToTimeField(el);
                    break;
                
            }
        }
    },
    
    // private
    convertToDateField : function(el) {
        var dt = new Ext.form.DateField({
            id: (el.id ? el.id : el.name),
            selectOnFocus: true,
            format: this.dateTimeFormats.dateFormat,
            width : this.getFieldWidth(el)
        });
        
        dt.applyToMarkup(el);
        // now add to items
        this.form.items.add(dt);
    },
    
    // private
    convertToTimeField : function(el){
    
        var tm = new Ext.nd.form.TimeField({
            width : this.getFieldWidth(el)
        });
        tm.applyToMarkup(el);
        // now add to items
        this.form.items.add(tm);                        
        
    },

    // private
    convertToCheckbox : function(el){
        var dfield = this.getFieldDefinition(el);
        var boxLabel = this.getDominoGeneratedBoxLabel(el, true);
        // TODO: figure out how to use columns and checkbox group
        var columns = Ext.DomQuery.selectValue('keywords/@columns');
        
        var ckb = new Ext.form.Checkbox({
            boxLabel : boxLabel
        });
        ckb.applyToMarkup(el);
        this.form.items.add(ckb);            

    },
    
    // private
    convertToRadio : function(el){
        var dfield = this.getFieldDefinition(el);
        var boxLabel = this.getDominoGeneratedBoxLabel(el, true);
        // TODO: figure out how to use columns and radio group
        var columns = Ext.DomQuery.selectValue('keywords/@columns');
        
        // Ext.form.Radio needs a unique id for each radio button
        // and this unique id needs to be on the corresponding
        // component
        
        el.id = Ext.id();
        
        var rd = new Ext.form.Radio({
            id : el.id,
            boxLabel : boxLabel
        });
        rd.applyToMarkup(el);
        this.form.items.add(rd);

    },

    // private
    getDominoGeneratedBoxLabel : function(el, removeLabel){

        var boxLabel = '';
        var boxLabelNode = el.nextSibling;
        
        if (boxLabelNode &amp;&amp; boxLabelNode.nodeType == 3) {
            boxLabel = boxLabelNode.nodeValue;
            
            if (removeLabel) {
                // remove domino's generated br tag
                var br = Ext.get(el).next();
                if (br != null &amp;&amp; br.dom.nodeName == 'BR') {
                    br.remove();
                }    
                // now remove the boxLabel node
                boxLabelNode.parentNode.removeChild(boxLabelNode);
            }
        }

        return boxLabel;
    },
    
    // private
    convertKeywordField : function(el){

        var dfield = this.getFieldDefinition(el);
        if (dfield) {
            var allowMultiValues = (Ext.DomQuery.selectValue('@allowmultivalues',dfield) == 'true') ? true : false;
            var allowNew = (Ext.DomQuery.selectValue('keywords/@allownew',dfield) == 'true') ? true : false;
            var choicesdialog = Ext.DomQuery.selectValue('@choicesdialog',dfield);
            
            // for an addressbook dialog
            if (choicesdialog == &quot;addressbook&quot;) {
                this.convertToNamePicker(el, {
                    multipleSelection : allowMultiValues,
                    allowNew : allowNew                                    
                });
                return;
            }
            
            // for ACL dialog
            if (choicesdialog == &quot;acl&quot;) {
                this.convertToACLDialog(el, {
                    multipleSelection : allowMultiValues,
                    allowNew : allowNew                                    
                });
                return;
            }
            
            if (choicesdialog == 'view') {
                this.convertToPickList(el, {
                    type : 'custom',
                    viewName : Ext.DomQuery.selectValue('@view', dfield),
                    column : Ext.DomQuery.selectNumber('@viewcolumn', dfield),
                    multipleSelection : allowMultiValues,
                    allowNew : allowNew                    
                });
                return;
            }
            
            // check now for a textlist or formula node
            var textlist = Ext.DomQuery.select('keywords/textlist',dfield);
            var formula = Ext.DomQuery.selectValue('keywords/formula',dfield, null);
            
            // if we have a textlist this process
            if (textlist.length &gt; 0) {
                this.convertToSelectFromTextlist(el, textlist);
                return;
            }
            
            //if we have a formula process
            if (formula) {
                this.convertToSelectFromFormula(el, formula);
                return;
            }
           
            return; //the below shouldn't be needed
       
        }
        
    },

    convertToSelectFromTextlist : function(el, textlist){
        
        // note that the mapping is to new String() due to a bug in Ext 
        // this bug is fixed in Ext 3.0 and in Ext 2.2.?
        // http://extjs.com/forum/showthread.php?t=63132
        var store = new Ext.data.Store({
            data: textlist,
            reader: new Ext.data.XmlReader({
                    record: &quot;text&quot;
                },
                [{
                    name:&quot;value&quot;, 
                    convert: function(v, n){
                        return Ext.DomQuery.selectValue('',n);
                    }
                }])
        });
        
        var combo = new Ext.form.ComboBox({
            //renderTo: el,
            displayField : &quot;value&quot;,
            store : store,
            typeAhead: true,
            mode: 'local',
            triggerAction: 'all',
            selectOnFocus:true,
            width : this.getFieldWidth(el)
        });
        
        // renderTo config option didn't work
        combo.applyToMarkup(el);
        
        // now add to items
        this.form.items.add(combo);
        
    },
    
    // private
    convertToACLDialog : function(el){
        
        //TODO - create ACL dialog
        
    },
    
    // private
    convertToSelectFromFormula : function(el, formula) {

        // use the Evaluate agent that evaluates @formulas
        var url = Ext.nd.extndUrl + 'Evaluate?OpenAgent';
        
        // make sure to set the baseParam to pass the current
        // db and unid as well as the formula to evaluate
        var store = new Ext.data.Store({
            proxy: new Ext.data.HttpProxy({
                method:'POST',
                url:url
            }),
            reader: new Ext.data.ArrayReader({},
                [{name:'value'}]
            ),
            baseParams: {
                formula : formula,
                db : this.dbPath, 
                unid : (this.document &amp;&amp; this.document.universalID) ? this.document.universalID : &quot;&quot;,
                form : this.formName,
                outputformat : 'json',
                convertresulttoarray : true
            }            
        });

        // for debugging TODO - remove when debugging complete
        store.on(&quot;load&quot;, function(store, records, options){
            var s = store;
            var r = records;
            var o = options;
        });
        
        
        var cb = new Ext.form.ComboBox({
            id: (el.id ? el.id : el.name),
            store : store,
            typeAhead: true,
            triggerAction: 'all',
            displayField: &quot;value&quot;,
            valueField: &quot;value&quot;,
            //renderTo: el,
            forceSelection: true,
            resizable: true,
            width : this.getFieldWidth(el)
        });
        
        cb.applyToMarkup(el);
        this.form.items.add(cb);
},
    
    // private
    convertToMultiSelect : function(el, forceSelection) {
        // TODO
    },
    
    // private 
    convertToAllowMultiValueSelect : function(el, forceSelection){
        // TODO
        //alert('allow multi value')
        //alert(el.name);    
    },
    
    // private
    convertSelectToComboBox : function(el, forceSelection){
        
        // if Domino wrapped the select el in a font tag then we need to
        // move this select out of this font tag and into div *before* 
        // this font tag
        if (el.parentNode.tagName == 'FONT') {
        	var cbContainer = Ext.DomHelper.insertBefore(el.parentNode, {
				tag: 'div'
			}, true);
			cbContainer.dom.appendChild(el);	
        }
        
        var s = Ext.getDom(el);
        var d = [], opts = s.options;
        var selectedValue = &quot;&quot;;
        var value;
        
        for(var i = 0, len = opts.length;i &lt; len; i++){
            var o = opts[i];
            value = (o.hasAttribute ? o.hasAttribute('value') : o.getAttribute('value') !== null) ? o.value : o.text;
            
            // correct the issue scene with IE when the option has an empty value tag
            value = (value == '' &amp;&amp; o.text != '') ? o.text : value;
            if(o.selected) {
                selectedValue = value;
            }
            d.push([value, o.text]);
        }
        
        var store = new Ext.data.ArrayStore({
            'id': 0,
            fields: ['value', 'text'],
            data : d,
            autoDestroy: true
        });
        
        var attr = el.attributes;
        var style = '';
        var cls = '';
        if (attr) {
        	var oStyle = attr.getNamedItem('style');
        	var oCls = attr.getNamedItem('class');
            style = oStyle ? oStyle.value : '';
            cls = oCls ? oCls.value : '';
        }
        var cb = new Ext.form.ComboBox({
            transform: el,
            id: (el.id ? el.id : el.name),
            hiddenName: el.name,
            store : store,
            mode : 'local',
            value : selectedValue,
            valueField : 'value',
            displayField : 'text',
            typeAhead: true,
            triggerAction: 'all',
            lazyRender: false, // docs say must be true since we are in an FormPanel but we need it set to false
            forceSelection: forceSelection,
            resizable: true,
            style : style,
            cls : cls,
            width : this.getFieldWidth(el)
        });
        
        // only setup domino's onchange event for keyword refreshes if the user
        // wants this
        // domino will do a postback to the server which may not be desired
        
        var extcallback = null;
        if (this.applyDominoKeywordRefresh) {
            // if domino sends an onchange attribute then grab it so we can
            // later add it to the onSelect event of ComboBox
            var attr = el.attributes;
            if (attr) {
                var onChange = attr['onchange'];
                
                // for some reason IE returns an onchange of null 
               	// if one isn't explicitly set    
                if (onChange &amp;&amp; onChange.nodeValue != null) {
                
                	var sOnChange = onChange.nodeValue;
                    
                    extcallback = function(){
                    	// only show the wait if this is a domino generated postback
                    	if (sOnChange.indexOf('$Refresh') &gt; 0) {
							Ext.MessageBox.wait(this.refreshMessage);
						}	
                    	eval(sOnChange);
                    }
                    
					// add a listener for the select event so we can
					// run the code we captured in the extcallback function
					cb.on('select', extcallback, this);
                }
            }
        } // end if (this.applyDominoKeywordRefresh)
        
        // now add to items
        this.form.items.add(cb);
        
    }, // end convertSelectToComboBox
    
    // private
    getFieldWidth : function(el){
    	var theEl = Ext.get(el);
        var w = theEl.getStyle('width');
        if (w.indexOf('%',0) &gt; 0) {
            return w; // support % widths
        } else if (parseFloat(w) == 0) {
        	return parseFloat(w); // if the developer really set width : 0 then return it!	
        } else {
        	var computedWidth = theEl.getComputedWidth(); 
        	// sometimes computed width can return 0 when the field is hidden on
        	// an inactive tab and thus we don't want to return 0
        	// TODO : need a better fix however, than returning the defaultFieldWidth
            return computedWidth == 0 ? this.defaultFieldWidth : computedWidth;
        }
    },
    
    fieldGetText : function(fld) {
        var oField = this.getForm().findField(fld);
        return (oField) ? oField.getValue() : '';
    },

    fieldSetText : function(fld, value) {
        var oField = this.getForm().findField(fld);
        if (oField) {
            try {
                oField.setValue(value);
            } catch(e){}
        }
    },

    fieldAppendText : function(fld, value) {
        var oField = this.getForm().findField(fld);
        if (oField) {
            try {
                oField.setValue(oField.getValue() + value);
            } catch(e){}
        }
    },

    fieldClear : function(fld) {
        var oField = this.getForm().findField(fld);
        if (oField) {
            try {
                oField.setValue(&quot;&quot;);
            } catch(e){}
        }
    },

    fieldContains : function(fld, searchString) {
        var oField = this.getForm().findField(fld);
        var bContains = false;
        if (oField) {
            try {
                var test = oField.getValue().indexOf(searchString);
                bContains = (test === -1) ? false : true;
            } catch(e){}
        }
        return bContains;
    },
    
    getTarget : function() {
        if (this.target) {
            return this.target;
        } else {
            // if a target property is available then set it
            if (window &amp;&amp; window.target) {
                this.target = window.target;
                return this.target;
            } else {
                // for an uiview or uidoc you need to go a level
                if (this.ownerCt &amp;&amp; this.ownerCt.getXType &amp;&amp; this.ownerCt.getXType() == 'tabpanel') {
                    this.target = this.ownerCt.id;
                    return this.target;
                } else {
                    return null;
                }
            }
        }
    },
    
    getIframeOwnerCt : function() {
        if (this.iframeOwnerCt) {
            return this.iframeOwnerCt;
        } else {
            // if a target property is available then set it
            // if an ownerCt property is available then set it
            if (window &amp;&amp; window.ownerCt) {
                this.iframeOwnerCt = window.ownerCt;
                return this.iframeOwnerCt;
            } else {
                return null;
            }
        }
    },

    getUIView: function() {
        if (this.uiView &amp;&amp; this.uiView != null) {
            return this.uiView;
        } else {
            if (window &amp;&amp; window.uiView) {
                this.uiView = window.uiView;
                return this.uiView
            } else {
                return null;
            }
        }
    },
    
    getUIDocument: function() {
        return this
    }
});
Ext.reg('xnd-uidocument', Ext.nd.UIDocument);

//for backwards compat
Ext.nd.Form = Ext.nd.UIDocument; 
//not sure why, but why not
Ext.nd.Page = Ext.nd.UIDocument; </pre>
</body>
</html>
