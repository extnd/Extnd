<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='Ext-nd-grid-ViewColumn'>/**
</span> * A Grid header type which renders a column for a Domino view.  This class is used by the Ext.nd.data.ViewDesign class
 * and you typically do not need to use this class directly.
 */
Ext.define('Ext.nd.grid.ViewColumn', {

    extend  : 'Ext.grid.column.Column',
    alias   : ['widget.xnd-viewcolumn'],

    requires: [
        'Ext.util.Format'
    ],

<span id='Ext-nd-grid-ViewColumn-property-align'>    /**
</span>     * @property align
     */
<span id='Ext-nd-grid-ViewColumn-property-dataIndex'>    /**
</span>     * @property dataIndex defaults to the name set for the column in Domino Designer
     */
<span id='Ext-nd-grid-ViewColumn-property-width'>    /**
</span>     * @property width
     */
<span id='Ext-nd-grid-ViewColumn-property-totals'>    /**
</span>     * @property totals
     */
<span id='Ext-nd-grid-ViewColumn-property-sortable'>    /**
</span>     * @property sortable
     */
<span id='Ext-nd-grid-ViewColumn-property-resortascending'>    /**
</span>     * @property resortascending
     */
<span id='Ext-nd-grid-ViewColumn-property-resortdescending'>    /**
</span>     * @property resortdescending
     */
<span id='Ext-nd-grid-ViewColumn-property-resortviewunid'>    /**
</span>     * @property resortviewunid
     */
<span id='Ext-nd-grid-ViewColumn-property-sortcategorize'>    /**
</span>     * @property sortcategorize
     */
<span id='Ext-nd-grid-ViewColumn-property-resize'>    /**
</span>     * @property resize
     */
<span id='Ext-nd-grid-ViewColumn-property-listseparator'>    /**
</span>     * @property listseparator
     */
<span id='Ext-nd-grid-ViewColumn-property-response'>    /**
</span>     * @property response
     */
<span id='Ext-nd-grid-ViewColumn-property-twistie'>    /**
</span>     * @property twistie
     */
<span id='Ext-nd-grid-ViewColumn-property-icon'>    /**
</span>     * @property icon
     */
<span id='Ext-nd-grid-ViewColumn-property-datetimeformat'>    /**
</span>     * @property datetimeformat
     */
<span id='Ext-nd-grid-ViewColumn-property-numberformat'>    /**
</span>     * @property numberformat
     */


    initComponent: function () {
        var me = this;

        // applyIf so that these can all be overridden if passed into the config
        Ext.applyIf(me, {
            dateTimeFormats     : Ext.nd.dateTimeFormats,
            formatCurrencyFnc   : Ext.util.Format.usMoney
        });

        me.callParent(arguments);
    },

<span id='Ext-nd-grid-ViewColumn-method-defaultRenderer'>    /**
</span>     * Default renderer method to handle column data in Domino Views
     */
    defaultRenderer: function (value, cell, record, rowIndex, colIndex, store) {
        var me                  = this,
            grid                = me.up('grid'),
            entryData           = record.viewEntry.entryData[me.dataIndex] || {},
            returnValue         = '',
            newValue,
            nextRecord          = store.getAt(rowIndex + 1),
            recordLevel         = record.viewEntry.depth,
            sCollapseImage      = '&lt;img src=&quot;' + grid.collapseIcon + '&quot; style=&quot;vertical-align:bottom; margin-right:8px;&quot;/&gt;',
            sExpandImage        = '&lt;img src=&quot;' + grid.expandIcon + '&quot; style=&quot;vertical-align:bottom; margin-right:8px;&quot;/&gt;',
            indentPadding       = (20 * recordLevel) + 'px',
            indentPaddingNoIcon = (20 + (20 * recordLevel)) + 'px',
            nextRecordLevel,
            indent,
            extraIndent,
            tmpReturnValue      = '',
            tmpValue            = '',
            separator           = me.getListSeparator(),
            clearFloat          = '',
            i,
            len = 0;


        // first check to see if this is a 'phantom' (new record being dynamically added
        // like in the RowEditor example and if so, just let it pass
        if (record.phantom === true) {
            return (value === undefined) ? '' : value;
        }

        // TODO: need to figure out why we sometimes get a null for the value
        if (value === null) {
            return '';
        }

        // next, let's split value into an array so that we can process the listseparator.  we use '\n' since that is how
        // we stored multi-values in the Ext.nd.data.ViewXmlReader#parseEntryDataChildNodes method.
        if (value &amp;&amp; value.split) {
            value = value.split('\n');
            len = value.length;
        }

        // if we don't have any data and this is not a response column
        // nor a category column then just return a blank
        if (typeof value === 'string' &amp;&amp; value === '' &amp;&amp; !me.response &amp;&amp; !entryData.category) {
            return '';
        }


        // has children and is a categorized column
        if (record.hasChildren() &amp;&amp; me.sortcategorize) {
            indent = entryData.indent;
            extraIndent = (indent &gt; 0) ? 'padding-left:' + indent * 20 + 'px;' : '';
            cell.attr = 'style=&quot;position: absolute; width: auto; white-space: nowrap; ' + extraIndent + '&quot;';

            if (nextRecord) {
                nextRecordLevel = nextRecord.viewEntry.depth;
                if (nextRecordLevel &gt; recordLevel) {
                    cell.css = ' xnd-view-collapse xnd-view-category';
                    returnValue = sCollapseImage + me.getValue(value, record);
                } else {
                    cell.css = ' xnd-view-expand xnd-view-category';
                    returnValue = sExpandImage + me.getValue(value, record);
                }
            } else { // should be a categorized column on the last record
                cell.css = ' xnd-view-expand xnd-view-category';
                returnValue = sExpandImage + me.getValue(value, record);
            }

        } else {

            // is NOT a category but has children and IS NOT a response doc BUT IS a response COLUMN
            if (!record.isCategory() &amp;&amp; record.hasChildren() &amp;&amp; !record.isResponse() &amp;&amp; me.response) {

                if (nextRecord) {
                    nextRecordLevel = nextRecord.viewEntry.depth;
                    if (nextRecordLevel &gt; recordLevel) {
                        cell.css = 'xnd-view-collapse xnd-view-response';
                        returnValue = sCollapseImage;
                    } else {
                        cell.css = 'xnd-view-expand xnd-view-response';
                        returnValue = sExpandImage;
                    }
                } else { // should be a categorized column on the last record
                    cell.css = 'xnd-view-expand xnd-view-response';
                    returnValue = sExpandImage;
                }

            } else {

                // has children and IS a response doc
                if (record.hasChildren() &amp;&amp; record.isResponse() &amp;&amp; me.response) {
                    indent = entryData.indent;
                    extraIndent = (indent &gt; 0) ? 'padding-left:' + (20 + (indent * 20)) + 'px;' : '';
                    cell.attr = 'style=&quot;position: absolute; width: auto; white-space: nowrap; ' + extraIndent + '&quot;';
                    if (nextRecord) {
                        nextRecordLevel = nextRecord.viewEntry.depth;
                        if (nextRecordLevel &gt; recordLevel) {
                            cell.css = 'xnd-view-collapse xnd-view-response';
                            returnValue = sCollapseImage + me.getValue(value, record);
                        } else {
                            cell.css = 'xnd-view-expand xnd-view-response';
                            returnValue = sExpandImage + me.getValue(value, record);
                        }
                    } else { // should be a categorized column on the last record
                        cell.css = 'xnd-view-expand xnd-view-response';
                        returnValue = sExpandImage + me.getValue(value, record);
                    }
                } else {

                    // does NOT have children and IS a response doc
                    if (!record.hasChildren() &amp;&amp; record.isResponse() &amp;&amp; me.response) {

                        cell.css = 'xnd-view-response';
                        indent = entryData.indent;
                        extraIndent = (indent &gt; 0) ? 'padding-left:' + (20 + (indent * 20)) + 'px;' : '';
                        cell.attr = 'style=&quot;position: absolute; width: auto; white-space: nowrap; ' + extraIndent + '&quot;';
                        returnValue = me.getValue(value, record);

                    } else {

                        if (me.icon) {
                            for (i = 0; i &lt; len; i++) {
                                tmpValue = value[i];

                                if (isNaN(parseInt(tmpValue, 10)) || tmpValue === '0') {
                                    return '';
                                } else {
                                    // I believe the domino only has view icon images from 1 to 186
                                    newValue = (tmpValue &lt; 10) ? '00' + tmpValue : (tmpValue &lt; 100) ? '0' + tmpValue : (tmpValue &gt; 186) ? '186' : tmpValue;
                                    clearFloat = (me.listseparator === 'newline') ? 'style=&quot;clear: left;&quot;' : '';
                                    tmpReturnValue = '&lt;div class=&quot;xnd-icon-vw xnd-icon-vwicn' + newValue + '&quot; ' + clearFloat + '&gt;&amp;nbsp;&lt;/div&gt;';
                                    if (i === 0) {
                                        returnValue = tmpReturnValue;
                                    } else {
                                        returnValue = returnValue + separator + tmpReturnValue;
                                    }
                                }
                            }

                        } else {
                            // just normal data but check first to see if a 'totals' column
                            if (me.totals !== 'none') {
                                cell.css = ' xnd-view-totals xnd-view-' + me.totals;
                            }
                            returnValue = me.getValue(value, record);
                        }
                    }
                }
            }
        }

        // now return our domino formatted value
        return returnValue;

    },

<span id='Ext-nd-grid-ViewColumn-method-getValue'>    // private
</span>    getValue: function (value, record) {
        var me = this,
            sep,
            tmpDate,
            tmpDateFmt,
            tmpValue,
            entryData   = record.viewEntry.entryData[me.dataIndex] || {},
            dataType    = entryData.type,
            nbf         = me.numberformat,
            dtf         = me.datetimeformat,
            separator   = me.getListSeparator(),
            newValue    = '',
            i,
            len;

        // handle non-categorized columns
        if (me.sortcategorize &amp;&amp; value.length === 0) {
            newValue = me.notCategorizedText;
        }

        // need to make sure value is an array
        // the loop below will format as needed
        value = (Ext.isArray(value)) ? value : ['' + value];
        len = value.length;

        for (i = 0, len; i &lt; len; i++) {
            sep = (i + 1 &lt; len) ? separator : '';
            tmpValue = value[i];

            // handle columns set to show an icon a little differently
            if (me.icon) {
                if (isNaN(parseInt(tmpValue, 10)) || tmpValue === 0) {
                    return '';
                } else {
                    // I believe domino only has view icon images from 1 to 186
                    newValue = (tmpValue &lt; 10) ? '00' + tmpValue : (tmpValue &lt; 100) ? '0' + tmpValue : (tmpValue &gt; 186) ? '186' : tmpValue;
                    return '&lt;img src=&quot;/icons/vwicn' + newValue + '.gif&quot;/&gt;';
                }

            } else if (me.totals === 'percentoverall' || me.totals === 'percentparent') {
                return Ext.util.Format.round(100 * parseFloat(tmpValue), nbf.digits) + '%';

            } else {

                switch (dataType) {

                    case 'datetimelist':
                    case 'datetime':
                        if (dtf.show === undefined) {
                            dtf.show = me.dateTimeFormats.show;
                        }
                        if (tmpValue.indexOf('T') &gt; 0) {
                            tmpDate = tmpValue.split(',')[0].replace('T', '.');
                            tmpDateFmt = 'Ymd.His';
                        } else {
                            tmpDate = tmpValue;
                            tmpDateFmt = 'Ymd';
                            dtf.show = 'date'; // switch to date only since there isn't a time component present
                        }
                        tmpDate = Ext.Date.parse(tmpDate, tmpDateFmt);
                        switch (dtf.show) {
                            case 'date':
                                tmpValue = tmpDate ? Ext.Date.format(tmpDate, me.dateTimeFormats.dateFormat) : '';
                                break;
                            case 'datetime':
                                tmpValue = tmpDate ? Ext.Date.format(tmpDate, me.dateTimeFormats.dateTimeFormat) : '';
                                break;
                        }
                        break;

                    case 'textlist':
                    case 'text':
                        tmpValue = tmpValue;
                        break;

                    case 'numberlist':
                    case 'number':
                        tmpValue = parseFloat(tmpValue);

                        switch (nbf.format) {
                            case 'currency':
                                tmpValue = Ext.isEmpty(tmpValue) ? me.formatCurrencyFnc(0) : me.formatCurrencyFnc(tmpValue);
                                break;

                            case 'fixed' :
                            case 'scientific' :
                                if (nbf.percent) {
                                    tmpValue = Ext.util.Format.round(100 * tmpValue, nbf.digits) + '%';
                                } else {
                                    tmpValue = Ext.util.Format.round(tmpValue, nbf.digits);
                                }
                                break;

                            default :
                                tmpValue = tmpValue;
                        }
                        break;

                    default:
                        tmpValue = tmpValue;
                }

                newValue = newValue + tmpValue + sep;

            }
        }

        return newValue;
    },

<span id='Ext-nd-grid-ViewColumn-method-getListSeparator'>    /**
</span>     * Returns an appropriate separator string that can be used in html
     */
    getListSeparator : function () {
        var me = this,
            separator = '';

        switch (me.listseparator) {
            case 'none':
                separator = '';
                break;
            case 'space':
                separator = ' ';
                break;
            case 'comma':
                separator = ',';
                break;
            case 'newline':
                separator = '&lt;br/&gt;';
                break;
            case 'semicolon':
                separator = ';';
                break;
            default:
                separator = '';
        }

        return separator;
    }

});
</pre>
</body>
</html>
